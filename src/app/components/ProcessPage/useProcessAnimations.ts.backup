"use client";

import { useEffect, useLayoutEffect } from "react";
import gsap from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";

interface ProcessAnimationRefs {
  pathRef: React.RefObject<SVGPathElement | null>;
  pathMobileRef: React.RefObject<SVGPathElement | null>;
  svgSectionRef: React.RefObject<HTMLElement | null>;
  cardRefs: React.MutableRefObject<(HTMLDivElement | null)[]>;
  imgRefs: React.MutableRefObject<(HTMLDivElement | null)[]>;
  heroTitleRef: React.RefObject<HTMLHeadingElement | null>;
  heroIntroRef: React.RefObject<HTMLParagraphElement | null>;
  heroLineRef: React.RefObject<HTMLDivElement | null>;
}

export function useProcessAnimations(refs: ProcessAnimationRefs, processData: unknown) {
  const {
    pathRef,
    pathMobileRef,
    svgSectionRef,
    cardRefs,
    imgRefs,
    heroTitleRef,
    heroIntroRef,
    heroLineRef,
  } = refs;

  // SVG initialization - tylko raz w useLayoutEffect
  useLayoutEffect(() => {
    const paths = [pathRef.current, pathMobileRef.current].filter(Boolean) as SVGPathElement[];
    paths.forEach((path) => {
      const len = path.getTotalLength();
      path.style.strokeDasharray = String(len);
      path.style.strokeDashoffset = String(len);
      path.style.opacity = "0";
    });
  }, [pathRef, pathMobileRef]);

  // Hero animations - mobile wyłączone
  useLayoutEffect(() => {
    const isMobile = typeof window !== "undefined" && window.matchMedia("(max-width: 767px)").matches;
    const title = heroTitleRef.current;
    const intro = heroIntroRef.current;
    const line = heroLineRef.current;

    if (isMobile) {
      if (title) {
        title.classList.remove("opacity-0");
        title.style.opacity = "1";
      }
      if (intro) {
        intro.classList.remove("opacity-0");
        intro.style.opacity = "1";
      }
      if (line) {
        line.classList.remove("opacity-0");
        line.style.opacity = "1";
      }
      return;
    }
  }, [heroTitleRef, heroIntroRef, heroLineRef]);

  useEffect(() => {
    const isMobile = typeof window !== "undefined" && window.matchMedia("(max-width: 767px)").matches;
    if (isMobile) return;

    const title = heroTitleRef.current;
    const intro = heroIntroRef.current;
    const line = heroLineRef.current;
    const tl = gsap.timeline({ defaults: { ease: "power3.out" } });
    if (title) tl.fromTo(title, { opacity: 0, y: 24 }, { opacity: 1, y: 0, duration: 0.8, force3D: true });
    if (intro) tl.fromTo(intro, { opacity: 0, y: 16 }, { opacity: 1, y: 0, duration: 0.6, force3D: true }, "-=0.5");
    if (line) tl.fromTo(line, { opacity: 0, scaleX: 0 }, { opacity: 1, scaleX: 1, duration: 0.6, force3D: true }, "-=0.35");

    return () => {
      tl.kill();
    };
  }, [heroTitleRef, heroIntroRef, heroLineRef]);

  // SVG Path animation - maksymalnie uproszczona wersja
  useEffect(() => {
    const path = pathRef.current;
    const pathMobile = pathMobileRef.current;
    const svgSection = svgSectionRef.current;
    
    if (!svgSection || (!path && !pathMobile)) return;

    const ctx = gsap.context(() => {
      const paths: SVGPathElement[] = [];
      if (path) paths.push(path);
      if (pathMobile) paths.push(pathMobile);

      // Prosty ScrollTrigger config
      const footer = document.querySelector("footer");
      const scrollConfig = {
        trigger: svgSection,
        start: "top 50%",
        end: footer ? "bottom bottom" : "bottom 70%",
        scrub: true,
      };

      // Animacja SVG - najprostsza możliwa
      paths.forEach((p) => {
        const pathLength = parseFloat(p.style.strokeDasharray);
        if (!pathLength) return;

        gsap.fromTo(
          p,
          { strokeDashoffset: pathLength, opacity: 0 },
          {
            strokeDashoffset: 0,
            opacity: 1,
            ease: "none",
            scrollTrigger: scrollConfig,
          }
        );
      });

      // Cards - prostsze animacje bez onUpdate
      imgRefs.current.forEach((el) => el && (el.style.opacity = "0.5"));
      cardRefs.current.forEach((el) => el && (el.style.opacity = "0.5"));

      // Prostsze animacje cards - użyj ScrollTrigger dla każdego elementu osobno
      cardRefs.current.forEach((card, i) => {
        if (!card) return;
        const img = imgRefs.current[i];
        
        ScrollTrigger.create({
          trigger: card,
          start: "top 80%",
          onEnter: () => {
            card.style.opacity = "1";
            if (img) img.style.opacity = "1";
          },
        });
      });

      // Parallax tylko na desktop
      const isMobileView = window.matchMedia("(max-width: 767px)").matches;
      if (!isMobileView) {
        cardRefs.current.forEach((card) => {
          if (!card) return;
          gsap.to(card, {
            y: -120,
            ease: "none",
            scrollTrigger: {
              trigger: card,
              start: "top bottom",
              end: "bottom top",
              scrub: true,
            },
          });
        });
      }
    });

    // Jeden refresh
    const timeout = setTimeout(() => ScrollTrigger.refresh(), 200);

    return () => {
      clearTimeout(timeout);
      ctx.revert();
    };
  }, [pathRef, pathMobileRef, svgSectionRef, cardRefs, imgRefs, processData]);
}
